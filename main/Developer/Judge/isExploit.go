package Judge

import (
	format2 "Scanner/main/Developer/Format"
	"fmt"
	"io"
	"net/http"
	"os"
	"reflect"
	"regexp"
	"strings"
)

func IsExploitSuccess(pocStruct format2.PocStruct, procedureResponse *http.Response, customRequestBody []byte) bool {
	var currentGroupIndex = 0
	var index = 0
	var groupNumIndex []map[int]int
	var isExploit []map[string][]bool
	// Because crossbars cannot appear in variables, conversion is required
	headerFieldsConvert := map[string]string{
		"UserAgent":   "User-Agent",
		"ContentType": "Content-Type",
	}

	for _, currentGroup := range pocStruct.ResponsePackage.Group {
		headerFields := map[string]string{
			"UserAgent":      pocStruct.ResponsePackage.Group[currentGroupIndex].Header.UserAgent,
			"AcceptEncoding": pocStruct.ResponsePackage.Group[currentGroupIndex].Header.AcceptEncoding,
			"Accept":         pocStruct.ResponsePackage.Group[currentGroupIndex].Header.Accept,
			"Host":           pocStruct.ResponsePackage.Group[currentGroupIndex].Header.Host,
			"Content-Type":   pocStruct.ResponsePackage.Group[currentGroupIndex].Header.ContentType,
		}

		currentGroupReflect := reflect.ValueOf(currentGroup)
		currentGroupReflectType := currentGroupReflect.Type()

		isExploit = append(isExploit, map[string][]bool{
			"flag": {},
		})

		var currentGroupHeaderKeyList []string
		index = 0
		// 逐行解释修改
		bodyOfExecutionResults, err := io.ReadAll(procedureResponse.Body)
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
		for i := 0; i < currentGroupReflectType.NumField(); i++ {
			currentGroupReflectField := currentGroupReflectType.Field(i)
			currentGroupReflectFieldValue := currentGroupReflect.FieldByName(currentGroupReflectField.Name)
			currentGroupReflectFieldValueInterface := currentGroupReflectFieldValue.Interface()

			if currentGroupReflectFieldValue.String() != "" {
				if currentGroupReflectField.Name == "Regexp" {
					matchesForRegexp := regexp.MustCompile(currentGroupReflectFieldValueInterface.(string)).FindStringSubmatch(string(bodyOfExecutionResults))
					if matchesForRegexp != nil && len(matchesForRegexp) > 1 {
						isExploit[currentGroupIndex]["flag"] = append(isExploit[currentGroupIndex]["flag"], true)
						break
					}
					var headerStringResult string
					for headerKey, headerValue := range procedureResponse.Header {
						headerStringResult += fmt.Sprintf("%s: %s\r\n", headerKey, headerValue)
					}
					matchesForRegexp = regexp.MustCompile(currentGroupReflectFieldValueInterface.(string)).FindStringSubmatch(headerStringResult)
					if matchesForRegexp != nil && len(matchesForRegexp) > 1 {
						isExploit[currentGroupIndex]["flag"] = append(isExploit[currentGroupIndex]["flag"], true)
					} else {
						isExploit[currentGroupIndex]["flag"] = append(isExploit[currentGroupIndex]["flag"], false)
					}
				} else if headerEntity, ok := currentGroupReflectFieldValueInterface.(format2.Header); ok {
					headerEntityValue := reflect.ValueOf(headerEntity)

					var times = 0
					for i := 0; i < headerEntityValue.NumField(); i++ {
						field := headerEntityValue.Type().Field(i)
						fieldValue := headerEntityValue.Field(i)

						if fieldValue.String() != "" {
							currentGroupHeaderKeyList = append(currentGroupHeaderKeyList, field.Name)
							times++
						}
					}

					for index = 0; index < len(currentGroupHeaderKeyList); index++ {
						var headerKey string
						if headerFieldsConvert[currentGroupHeaderKeyList[index]] != "" {
							headerKey = headerFieldsConvert[currentGroupHeaderKeyList[index]]
						} else {
							headerKey = currentGroupHeaderKeyList[index]
						}

						if expectedValue, ok := headerFields[headerKey]; ok && (expectedValue == procedureResponse.Header.Get(headerKey) || strings.Contains(procedureResponse.Status, expectedValue)) {
							isExploit[currentGroupIndex]["flag"] = append(isExploit[currentGroupIndex]["flag"], true)
						} else {
							isExploit[currentGroupIndex]["flag"] = append(isExploit[currentGroupIndex]["flag"], false)
						}
					}

				} else {
					if len(bodyOfExecutionResults) != 0 {
						customRequestBody = bodyOfExecutionResults
					}

					index = index + len(pocStruct.ResponsePackage.Group[currentGroupIndex].Body) - 1
					isFalseFlag := false
					customRequestBodyString := string(customRequestBody)
					// 遍历获取 poc.json 中的body,用于验证response是否符合 poc.json
					for _, tmpPocBody := range pocStruct.ResponsePackage.Group[currentGroupIndex].Body {
						if strings.Contains(customRequestBodyString, tmpPocBody) {
							isExploit[currentGroupIndex]["flag"] = append(isExploit[currentGroupIndex]["flag"], true)
							isFalseFlag = true
							break
						}
					}
					if !isFalseFlag {
						isExploit[currentGroupIndex]["flag"] = append(isExploit[currentGroupIndex]["flag"], false)
					}

				}
			}
		}
		groupNumIndex = append(groupNumIndex, map[int]int{
			currentGroupIndex: index + 1,
		})
		currentGroupIndex++
	}

	currentGroupIndex = currentGroupIndex - 1
	var isConform = true
	if pocStruct.ResponsePackage.Operation == "AND" {
		for index := 0; index <= currentGroupIndex && isConform; index++ {
			for j := 0; j < groupNumIndex[index][index]; j++ {
				if !isExploit[index]["flag"][j] {
					isConform = false
					break
				}
			}
		}
	} else {
		allGroupFlagList := make([]bool, currentGroupIndex+1)
		for index := 0; index <= currentGroupIndex; index++ {
			currentGroupFlag := true
			for j := 0; j < groupNumIndex[index][index]; j++ {
				if !isExploit[index]["flag"][j] {
					currentGroupFlag = false
					break
				}
			}
			allGroupFlagList[index] = currentGroupFlag
		}
		isConform = false
		for _, groupFlag := range allGroupFlagList {
			if groupFlag {
				isConform = true
				break
			}
		}
	}
	return isConform
}
