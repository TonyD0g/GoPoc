package Judge

import (
	format2 "Scanner/main/Developer/format"
	"fmt"
	"io"
	"net/http"
	"os"
	"reflect"
	"strings"
)

func IsExploitSuccess(pocStruct format2.PocStruct, procedureResponse *http.Response, customRequestBody []byte) bool {
	var currentGroupIndex = 0
	var index = 0
	var groupNumIndex []map[int]int
	var isExploit []map[string][]bool
	// Because crossbars cannot appear in variables, conversion is required
	headerFieldsConvert := map[string]string{
		"UserAgent":   "User-Agent",
		"ContentType": "Content-Type",
	}

	for _, currentGroup := range pocStruct.ResponsePackage.Group {
		headerFields := map[string]string{
			"UserAgent":      pocStruct.ResponsePackage.Group[currentGroupIndex].Header.UserAgent,
			"AcceptEncoding": pocStruct.ResponsePackage.Group[currentGroupIndex].Header.AcceptEncoding,
			"Accept":         pocStruct.ResponsePackage.Group[currentGroupIndex].Header.Accept,
			"Cookie":         pocStruct.ResponsePackage.Group[currentGroupIndex].Header.Cookie,
			"Host":           pocStruct.ResponsePackage.Group[currentGroupIndex].Header.Host,
			"Content-Type":   pocStruct.ResponsePackage.Group[currentGroupIndex].Header.ContentType,
			"Status":         pocStruct.ResponsePackage.Group[currentGroupIndex].Header.Status,
		}

		currentGroupReflect := reflect.ValueOf(currentGroup)
		currentGroupReflectType := currentGroupReflect.Type()

		isExploit = append(isExploit, map[string][]bool{
			"flag": {},
		})

		var currentGroupHeaderKeyList []string
		index = 0

		for i := 0; i < currentGroupReflectType.NumField(); i++ {
			currentGroupReflectField := currentGroupReflectType.Field(i)
			currentGroupReflectFieldName := currentGroupReflectField.Name

			currentGroupReflectFieldValue := currentGroupReflect.FieldByName(currentGroupReflectFieldName)
			currentGroupReflectFieldValueInterface := currentGroupReflectFieldValue.Interface()

			if currentGroupReflectFieldValue.String() != "" {
				if headerEntity, ok := currentGroupReflectFieldValueInterface.(format2.Header); ok {
					headerEntityValue := reflect.ValueOf(headerEntity)

					var times = 0
					for i := 0; i < headerEntityValue.NumField(); i++ {
						field := headerEntityValue.Type().Field(i)
						fieldValue := headerEntityValue.Field(i)

						if fieldValue.String() != "" {
							currentGroupHeaderKeyList = append(currentGroupHeaderKeyList, field.Name)
							times++
						}
					}

					for index = 0; index < len(currentGroupHeaderKeyList); index++ {
						var headerKey string
						if headerFieldsConvert[currentGroupHeaderKeyList[index]] != "" {
							headerKey = headerFieldsConvert[currentGroupHeaderKeyList[index]]
						} else {
							headerKey = currentGroupHeaderKeyList[index]
						}

						if expectedValue, ok := headerFields[headerKey]; ok && (expectedValue == procedureResponse.Header.Get(headerKey) || strings.Contains(procedureResponse.Status, expectedValue)) {
							isExploit[currentGroupIndex]["flag"] = append(isExploit[currentGroupIndex]["flag"], true)
						} else {
							isExploit[currentGroupIndex]["flag"] = append(isExploit[currentGroupIndex]["flag"], false)
						}
					}

				} else {
					bodyOfExecutionResults, err := io.ReadAll(procedureResponse.Body)
					if err != nil {
						fmt.Println(err)
						os.Exit(1)
					}

					if len(bodyOfExecutionResults) != 0 {
						customRequestBody = bodyOfExecutionResults
					}

					index = index + len(pocStruct.ResponsePackage.Group[currentGroupIndex].Body) - 1
					// todo 在body中增加一个: "[regexp]``" ,用于使用正则匹配responseBody
					if ContainsAny(string(customRequestBody), pocStruct.ResponsePackage.Group[currentGroupIndex].Body) {
						isExploit[currentGroupIndex]["flag"] = append(isExploit[currentGroupIndex]["flag"], true)
					} else {
						isExploit[currentGroupIndex]["flag"] = append(isExploit[currentGroupIndex]["flag"], false)
					}
				}
			}
		}
		groupNumIndex = append(groupNumIndex, map[int]int{
			currentGroupIndex: index + 1,
		})
		currentGroupIndex++
	}

	currentGroupIndex = currentGroupIndex - 1
	var isConform = true
	if pocStruct.ResponsePackage.Operation == "AND" {
		for index := 0; index <= currentGroupIndex && isConform; index++ {
			for j := 0; j < groupNumIndex[index][index]; j++ {
				if !isExploit[index]["flag"][j] {
					isConform = false
					break
				}
			}
		}
	} else {
		allGroupFlagList := make([]bool, currentGroupIndex+1)
		for index := 0; index <= currentGroupIndex; index++ {
			currentGroupFlag := true
			for j := 0; j < groupNumIndex[index][index]; j++ {
				if !isExploit[index]["flag"][j] {
					currentGroupFlag = false
					break
				}
			}
			allGroupFlagList[index] = currentGroupFlag
		}
		isConform = false
		for _, groupFlag := range allGroupFlagList {
			if groupFlag {
				isConform = true
				break
			}
		}
	}
	return isConform
}

func ContainsAny(target string, slice []string) bool {
	for _, s := range slice {
		if strings.Contains(target, s) {
			return true
		}
	}
	return false
}
