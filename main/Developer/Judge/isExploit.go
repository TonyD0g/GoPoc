package Judge

import (
	format2 "GoPoc/main/Developer/AllFormat"
	"fmt"
	"io"
	"net/http"
	"os"
	"regexp"
	"strings"
)

func IsExploitSuccessByJson(pocStruct format2.PocStruct, procedureResponse *http.Response, customRequestBody []byte) bool {
	var currentGroupIndex = 0
	var index = 0
	var groupNumIndex []map[int]int
	var isExploit []map[string][]bool
	for _, currentGroup := range pocStruct.ResponsePackage.Group {
		isExploit = append(isExploit, map[string][]bool{
			"flag": {},
		})
		index = 0
		NumberOfMembers := 0
		bodyOfExecutionResults, err := io.ReadAll(procedureResponse.Body)
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
		if currentGroup.Regexp != "" {
			NumberOfMembers++
			matchesForRegexp := regexp.MustCompile(currentGroup.Regexp).FindStringSubmatch(string(bodyOfExecutionResults))
			if matchesForRegexp != nil && len(matchesForRegexp) > 1 {
				isExploit[currentGroupIndex]["flag"] = append(isExploit[currentGroupIndex]["flag"], true)
				break
			}
			var headerStringResult string
			for headerKey, headerValue := range procedureResponse.Header {
				headerStringResult += fmt.Sprintf("%s: %s\r\n", headerKey, headerValue)
			}
			matchesForRegexp = regexp.MustCompile(currentGroup.Regexp).FindStringSubmatch(headerStringResult)
			if matchesForRegexp != nil && len(matchesForRegexp) > 1 {
				isExploit[currentGroupIndex]["flag"] = append(isExploit[currentGroupIndex]["flag"], true)
			} else {
				isExploit[currentGroupIndex]["flag"] = append(isExploit[currentGroupIndex]["flag"], false)
			}
		}
		if currentGroup.Header != nil {
			NumberOfMembers++
			for headerName, headerValue := range currentGroup.Header {
				if headerValue == procedureResponse.Header.Get(headerName) ||
					(headerName == "Status" && strings.Contains(procedureResponse.Status, headerValue.(string))) {
					isExploit[currentGroupIndex]["flag"] = append(isExploit[currentGroupIndex]["flag"], true)
				} else {
					isExploit[currentGroupIndex]["flag"] = append(isExploit[currentGroupIndex]["flag"], false)
				}
			}
		}
		if currentGroup.Body != nil {
			NumberOfMembers++
			if len(bodyOfExecutionResults) != 0 {
				customRequestBody = bodyOfExecutionResults
			}

			index = index + len(pocStruct.ResponsePackage.Group[currentGroupIndex].Body) - 1
			isFalseFlag := false
			customRequestBodyString := string(customRequestBody)
			// 遍历获取 poc.json 中的body,用于验证response是否符合 poc.json
			for _, tmpPocBody := range pocStruct.ResponsePackage.Group[currentGroupIndex].Body {
				if strings.Contains(customRequestBodyString, tmpPocBody) {
					isExploit[currentGroupIndex]["flag"] = append(isExploit[currentGroupIndex]["flag"], true)
					isFalseFlag = true
					break
				}
			}
			if !isFalseFlag {
				isExploit[currentGroupIndex]["flag"] = append(isExploit[currentGroupIndex]["flag"], false)
			}
		}
		if NumberOfMembers == 0 {
			fmt.Println("poc 书写有问题,Group 中的某个为空")
			os.Exit(1)
		}
		groupNumIndex = append(groupNumIndex, map[int]int{
			currentGroupIndex: index + 1,
		})
		currentGroupIndex++
	}

	// 依据 逻辑符号(or/and)来判断是否验证成功
	currentGroupIndex = currentGroupIndex - 1
	var isConform = true
	if strings.ToLower(pocStruct.ResponsePackage.Operation) == "and" {
		for index := 0; index <= currentGroupIndex && isConform; index++ {
			for j := 0; j < groupNumIndex[index][index]; j++ {
				if !isExploit[index]["flag"][j] {
					isConform = false
					break
				}
			}
		}
	} else {
		allGroupFlagList := make([]bool, currentGroupIndex+1)
		for index := 0; index <= currentGroupIndex; index++ {
			currentGroupFlag := true
			for j := 0; j < groupNumIndex[index][index]; j++ {
				if !isExploit[index]["flag"][j] {
					currentGroupFlag = false
					break
				}
			}
			allGroupFlagList[index] = currentGroupFlag
		}
		isConform = false
		for _, groupFlag := range allGroupFlagList {
			if groupFlag {
				isConform = true
				break
			}
		}
	}
	return isConform
}
